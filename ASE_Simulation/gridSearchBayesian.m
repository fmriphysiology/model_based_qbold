function gridSearchBayesian
% gridSearchBayesian.m
%
% Perform Bayesian inference on simulated ASE qBOLD data, generated by
% Simulate_qASE.m. Requires a .mat file of the right format, which should be
% in the same folder.
%
% 
%       Copyright (C) University of Oxford, 2016-2019
%
% 
% Created by MT Cherukara, 17 May 2016
%
% CHANGELOG:
%
% 2019-06-11 (MTC). Updated for resubmission of model-fitting paper.
%
% 2018-02-12 (MTC). Went back to 'param_update' since it is actually much
%       faster. Removed the 3D grid search code because it was taking up space
%       (it will be in the repository somewhere).
%
% 2018-02-05 (MTC). Removed the need for the 'param_update' function. Fixed a
%       bug in the 1D grid search method.
%
% 2018-01-12 (MTC). Changed the way the posterior is calculated to actually
%       calculate log-likelihood, using the function MTC_loglike.m. This
%       technically shouldn't alter the shape of any of the posterior
%       distributions (in terms of their linearity) but should mean that our
%       selected value of SNR is 'applied' to the results correctly.
%
% 2017-08-07 (MTC). Added R2'/DBV inference, and made the whole thing better
%       organised. The 1D grid search isn't working right, but it isn't
%       particularly important at this stage.
%
% 2017-04-04 (MTC). Various changes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%    Initialization          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Load the data
load('data_qASE_example.mat'); % this is generated by Simulate_qASE.m


% Parameters - choose one of these two
pnames = { 'OEF'    ; 'zeta'      };
interv = [ 0.2, 0.7 ; 0.003, 0.15 ];
np     = [ 100     ; 100        ];

% pnames = { 'R2p'    ; 'zeta'      };
% interv = [ 0.2, 15  ; 0.003, 0.15 ];
% np     = [ 1000     ; 1000        ];


% Model selection
params.model = 'Asymp';  % should the asymptotic tissue model be used?
params.incIV = 1;
params.incT1 = 1;

% extract relevant parameters
params.R2p = params.dw.*params.zeta;

sigma = mean(params.sig);


% are we inferring on R2'?
if any(strcmp(pnames,'R2p'))
    params.contr = 'R2p';
else
    params.contr = 'OEF';
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%    2D Grid Search          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% find true values of parameters
trv(1) = eval(['params.',pnames{1}]); % true value of parameter 1
trv(2) = eval(['params.',pnames{2}]); % true value of parameter 2

% generate parameter distributions
pv1 = linspace(interv(1,1),interv(1,2),np(1));
pv2 = linspace(interv(2,1),interv(2,2),np(2));

pos = zeros(np(1),np(2));

% This outer loop can be changed to "parfor" if you have the parallel computing
% toolbox. It makes things much faster.
for i1 = 1:np(1)
    % loop through parameter 1
    
    % create a parameters object
    looppars = updateParams(pv1(i1),params,pnames{1});
    posvec = zeros(1,np(2));
    
    pv22 = pv2; % to avoid using pv2 as a broadcast variable
    
    for i2 = 1:np(2)
        % loop through parameter 2
        
        % create a parameters object
        inpars = updateParams(pv22(i2),looppars,pnames{2});
        
        % run the model to evaluate the signal with current params
        S_mod = qASE_model(T_sample,TE_sample,inpars);
        
        % normalize (not necessary in double-FLAIR version)
        S_mod = S_mod./max(S_mod);
        
        % calculate posterior based on known noise value
        posvec(i2) = calcLogLikelihood(S_sample,S_mod,0.1);
        
    end % for i2 = 1:np2
    
    pos(i1,:) = posvec;
    
end % for i1 = 1:np1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%    Display Results         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% create figure
figure; hold on; box on;

% Plot 2D grid search results
surf(pv2,pv1,exp(0.01*pos));
view(2); shading flat;
axis square;
c=colorbar;
colormap(flipud(magma));
% plot3([trv(2),trv(2)],[  0, 1000],[1e40,1e40],'k-');
% plot3([  0, 1000],[trv(1),trv(1)],[1e40,1e40],'k-');


% x axis - DBV
if strcmp(pnames{2},'zeta')
    xticks(0.01:0.02:0.15);
    xlabel('\zeta (%)');
else
    xlabel(pnames{2});
end

% y axis - OEF
if strcmp(pnames{1},'OEF')
    yticks(0.2:0.1:0.7);
    yticklabels({'20','30','40','50','60','70'});
    ylabel('OEF (%)');
elseif strcmp(pnames{1},'R2p')
    ylabel('R_2'' (s^-^1)');
else
    ylabel(pnames{1});
end

ylabel(c,'Posterior Probability Density');
axis([min(pv2),max(pv2),min(pv1),max(pv1)]);
set(gca,'YDir','normal');

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%    Parameter update function         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function PARAMS = updateParams(VALUE,PARAMS,INFER)
    % Updates the PARAMS structure's entry named INFER to the number given in
    % VALUE.

    if strcmp(INFER,'OEF')
        PARAMS.OEF = VALUE;
    elseif strcmp(INFER,'zeta')
        PARAMS.zeta = VALUE;
    elseif strcmp(INFER,'R2p')
        PARAMS.R2p = VALUE;
    else
        disp('----updateParams: Invalid parameter specified');
    end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%    Calculate Likelihood         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function L = calcLogLikelihood(data,model,sigma)
    % Takes inputs of raw DATA (1xN vector), values generated by the MODEL
    % (also 1xN vector), and a noise standard deviation SIGMA (scalar). Returns
    % a scalar log likelihood value L.

    % make sure inputs are correct
    if (length(data) ~= length(model))
        error('Input Data and Model Data must be the same length!');
    end

    % extract N
    N = length(data);

    % compute maximum possible loglikelihood
    M = -0.5.*N.*log(2.*pi.*sigma.^2);

    % compute sum of square difference
    S = (1./(2.*sigma.^2)).*sum((data-model).^2);

    % add up loglikelihood
    L = M - S;
end
